/***********************************************************************************************************************
**                                                                                                                    **
** Copyright (C) iSOFT   (2021)                                                                                       **
**                                                                                                                    **
** All rights reserved.                                                                                               **
**                                                                                                                    **
** This document contains proprietary information belonging to iSOFT.                                                 **
** Passing on and copying of this document, and communication of its contents is not permitted                        **
** without prior written authorization.                                                                               **
**                                                                                                                    **
************************************************************************************************************************
**                                                                                                                    **
**  FILENAME    : TcpIp.c                                                                                             **
**                                                                                                                    **
**  Created on  : 03/12/18                                                                                            **
**  Author      : darren.zhang                                                                                        **
**  Vendor      :                                                                                                     **
**  DESCRIPTION : none                                                                                                **
**                                                                                                                    **
**  SPECIFICATION(S) :   AUTOSAR classic Platform R19-11                                                              **
**                                                                                                                    **
***********************************************************************************************************************/

/***********************************************************************************************************************
**                                          REVISION   HISTORY                                                        **
***********************************************************************************************************************/
/* <VERSION>    <DATE>       <AUTHOR>        <REVISION LOG>
 *  V1.0.0    [20190813]  [zhengfei.li]   Initial version
 *  V1.0.1    [20191129]  [zhengfei.li]   Through QAC testing, improve the code
 *  V1.0.2    [20191204]  [zhengfei.li]   When call TcpIp_RequestComMode(OFFLINE),  don't just change the socket
 *                                          state,need to free the lwip relate pcb.
 *  V1.0.3    [20191231]  [zhengfei.li]   UDP need to think about same port for UNICAST and MULTICAST
 *                                          (SD need the function).
 *  V1.0.4    [20200103]  [zhengfei.li]   Modify the lwip period timer handle bug
 *  V1.0.5    [20200107]  [zhengfei.li]   TcpIp_TcpErrCallback not to close the socket, the job is done by SoAd.
 *  V1.0.6    [20200110]  [zhengfei.li]   the lwip API udp_connect will connect the pcb with one specific
 *                                          remote address,will lead the pcb can't receive message from
 *                                          other remote note.
 *  V1.0.7    [20200115]  [zhengfei.li]   Solve different configurations cause compilation errors.
 *  V2.0.0    [20200828]  [pengfei.zhu]   Update to R19-11. Tcp/Udp_CopyTxData now have synchronous process.
 *                                          Add Tcp_Tls function. Add Enable/Disable Nagle algorithm of newPcb
 *                                          generated by listenPcb in TcpIp_TcpAcceptCallcback.
 *  V2.0.1    [20200928]  [pengfei.zhu]   QAC test.
 *  V2.0.2    [20210817]  [darren.zhang]  Code refactoring ,include code style and tls handle
 **********************************************************************************************************************/

/***********************************************************************************************************************
 *  INCLUDES
***********************************************************************************************************************/
#include "TcpIp.h"
#include "TcpIp_Lcfg.h"
#if (STD_ON == TCPIP_DEM_SUPPORT)
#include "Dem.h"
#endif /*STD_ON == TCPIP_DEM_SUPPORT*/
#include "SchM_TcpIp.h"
#include "TcpIp_PBcfg.h"
#include "TcpIp_Internal.h"
#include "EthIf.h"
/***********************************************************************************************************************
 *  LOCAL DATA TYPES AND STRUCTURES
***********************************************************************************************************************/
/***********************************************************************************************************************
 *  LOCAL CONSTANT MACROS
***********************************************************************************************************************/

/***********************************************************************************************************************
 *  LOCAL DATA
***********************************************************************************************************************/
#if (STD_ON == TCPIP_INITIALIZATION_AVAILABLE)
#define TCPIP_START_SEC_VAR_INIT_8
#include "TcpIp_MemMap.h"
TCPIP_LOCAL VAR(TcpIp_InitStateType, TCPIP_VAR_ZERO_INIT) TcpIp_InitState = TCPIP_STATE_UNINIT;
#define TCPIP_STOP_SEC_VAR_INIT_8
#include "TcpIp_MemMap.h"
#endif /* (STD_ON == TCPIP_INITIALIZATION_AVAILABLE) */

#define TCPIP_START_SEC_VAR_CLEARED_PTR
#include "TcpIp_MemMap.h"
TCPIP_LOCAL P2CONST(TcpIp_ConfigType, AUTOMATIC, TCPIP_VAR) TcpIp_PbCfgPtr;
#define TCPIP_STOP_SEC_VAR_CLEARED_PTR
#include "TcpIp_MemMap.h"

#define TCPIP_START_SEC_CONST_UNSPECIFIED
#include "TcpIp_MemMap.h"
TCPIP_LOCAL CONST(TcpIp_SocketParaHandleType, TCPIP_VAR) TcpIp_SocketParaHandleTebla[] =                                /* PRQA S 3218 */ /* MISRA Rule 8.9 */
{
    {TCPIP_PARAMID_FRAMEPRIO, TcpIp_ChanegeSocketParaFramePrio},
    {TCPIP_PARAMID_TCP_NAGLE, TcpIp_ChanegeSocketTcpNagle},
    {TCPIP_PARAMID_TTL, TcpIp_ChanegeSocketParaTtl},
#if (STD_ON == TCPIP_TCP_ENABLED)
    {TCPIP_PARAMID_TCP_RXWND_MAX, NULL_PTR},
    {TCPIP_PARAMID_TCP_KEEPALIVE, TcpIp_ChanegeSocketTcpKeepAlive},
    {TCPIP_PARAMID_TCP_KEEPALIVE_TIME, TcpIp_ChanegeSocketTcpKeepAlive},
    {TCPIP_PARAMID_TCP_KEEPALIVE_PROBES_MAX, TcpIp_ChanegeSocketTcpKeepAlive},
    {TCPIP_PARAMID_TCP_KEEPALIVE_INTERVAL, TcpIp_ChanegeSocketTcpKeepAlive},
    {TCPIP_PARAMID_TCP_OPTIONFILTER, NULL_PTR},
#endif/* (STD_ON == TCPIP_TCP_ENABLED) */
#if (STD_ON == TCPIP_TCP_TLS_ENABLED)
    {TCPIP_PARAMID_TLS_CONNECTION_ASSIGNMENT, TcpIp_TlsDynamicConnect},
#endif/* (STD_ON == TCPIP_TCP_TLS_ENABLED) */
    {TCPIP_PARAMID_PATHMTU_ENABLE, NULL_PTR},
    {TCPIP_PARAMID_FLOWLABEL, NULL_PTR},
    {TCPIP_PARAMID_DSCP, NULL_PTR},
#if (STD_ON == TCPIP_UDP_ENABLED)
    {TCPIP_PARAMID_UDP_CHECKSUM, NULL_PTR},
#endif/* (STD_ON == TCPIP_UDP_ENABLED) */
    {TCPIP_PARAMID_VENDOR_SPECIFIC, NULL_PTR},
};
#define TCPIP_STOP_SEC_CONST_UNSPECIFIED
#include "TcpIp_MemMap.h"


/***********************************************************************************************************************
**                                              Version                                                               **
***********************************************************************************************************************/
#define TCPIP_C_AR_MAJOR_VERSION                19
#define TCPIP_C_AR_MINOR_VERSION                11
#define TCPIP_C_AR_PATCH_VERSION                0
#define TCPIP_C_SW_MAJOR_VERSION                2
#define TCPIP_C_SW_MINOR_VERSION                0
#define TCPIP_C_SW_PATCH_VERSION                2
/***********************************************************************************************************************
 *  VERSION CHECK
***********************************************************************************************************************/
/* check the version of TcpIp header files */
#if (  (TCPIP_C_AR_MAJOR_VERSION != TCPIP_H_AR_MAJOR_VERSION) \
    || (TCPIP_C_AR_MINOR_VERSION != TCPIP_H_AR_MINOR_VERSION) \
    || (TCPIP_C_AR_PATCH_VERSION != TCPIP_H_AR_PATCH_VERSION) \
    || (TCPIP_C_SW_MAJOR_VERSION != TCPIP_H_SW_MAJOR_VERSION) \
    || (TCPIP_C_SW_MINOR_VERSION != TCPIP_H_SW_MINOR_VERSION) \
    )
#error "version numbers of TcpIp.h and TcpIp.c are inconsistent"
#endif

/* check the version of the configuration header file */
#if (  (TCPIP_C_AR_MAJOR_VERSION != TCPIP_CFG_H_AR_MAJOR_VERSION) \
    || (TCPIP_C_AR_MINOR_VERSION != TCPIP_CFG_H_AR_MINOR_VERSION) \
    || (TCPIP_C_AR_PATCH_VERSION != TCPIP_CFG_H_AR_PATCH_VERSION) \
    || (TCPIP_C_SW_MAJOR_VERSION != TCPIP_CFG_H_SW_MAJOR_VERSION) \
    || (TCPIP_C_SW_MINOR_VERSION != TCPIP_CFG_H_SW_MINOR_VERSION) \
    )
#error "version numbers of TcpIp_Cfg.h and TcpIp.c are inconsistent"
#endif

#define TCPIP_START_SEC_CODE
#include "TcpIp_MemMap.h"
/***********************************************************************************************************************
 *  LOCAL FUNCTIONS
***********************************************************************************************************************/
#if (TCPIP_LOCAL_ADR_NUM > 0)
/**
 * Up_LocalIpAddrAssignmentChg handle
 *
 * @param localAdrId local address id
 * @param ipAdrState @ref TcpIp_IpAddrStateType
 */
FUNC(void, TCPIP_CODE) TcpIp_NotfiyUpperLayerIpAdrChange(
    VAR(TcpIp_LocalAddrIdType, AUTOMATIC) localAdrId,
    VAR(TcpIp_IpAddrStateType, AUTOMATIC) ipAdrState)
{
#if defined(TCPIP_CHECK)

    if ((TcpIp_LCfg.SocketOwnerNum > 0u) && (TcpIp_LCfg.SocketOwnerLCfgPtr != NULL_PTR))
#endif/* defined(TCPIP_CHECK) */
    {
#if (STD_ON == TCPIP_MUILT_SOCKET_OWNERCFG)

        for (uintx index = 0; index < TcpIp_LCfg.SocketOwnerNum; index++)
#else/* (STD_ON != TCPIP_MUILT_SOCKET_OWNERCFG) */
        uintx index = 0;

#endif/* (STD_ON == TCPIP_MUILT_SOCKET_OWNERCFG) */
        {
            TcpIp_Up_LocalIpAddrAssignmentChgType localNotifyFuncPtr =
                TcpIp_LCfg.SocketOwnerLCfgPtr[index].Up_LocalIpAddrAssignmentChgFuncPtr;

            /* socket owner is essential spport LocalIpAddrAssignmentChg configurer parameter */
            if (NULL_PTR != localNotifyFuncPtr)
            {
                localNotifyFuncPtr(localAdrId, ipAdrState);
            }
        }
    }

#if defined(TCPIP_CHECK)
    else
    {
        TCPIP_CHECK_OUTPUT("link timer config not have socker owner\n");
    }

#endif/* defined(TCPIP_CHECK) */
}
#endif/* (TCPIP_LOCAL_ADR_NUM > 0) */

/***********************************************************************************************************************
 *  GLOBAL FUNCTIONS
 **********************************************************************************************************************/

/***********************************************************************************************************************
 * Service ID[hex]:     0x01
 * Sync/Async:          Synchronous
 * Reentrancy:          Non Reentrant
 * Parameters (in):     ConfigPtr Pointer to the configuration data of the TcpIp module
 * Parameters(inout):   None
 * Parameters (out):    None
 * Return value:        None
 * Description:         This service initializes the TCP/IP Stack.TcpIp_Init may not block the start-up process for an
 *                      indefinite amount of time.
 * Caveats:             The call of this service is mandatory before using the TcpIp instance for further processing.
***********************************************************************************************************************/
FUNC(void, TCPIP_CODE) TcpIp_Init(
    P2CONST(TcpIp_ConfigType, AUTOMATIC, TCPIP_APPL_CONST) ConfigPtr)
{
#if (STD_ON == TCPIP_DEV_ERROR_DETECT)

    if (NULL_PTR == ConfigPtr)
    {
        TCPIP_DET(TCPIP_SID_INIT, TCPIP_E_PARAM_POINTER);
    }
    else
#endif /* (STD_ON == TCPIP_DEV_ERROR_DETECT) */
    {
        TcpIp_PbCfgPtr = ConfigPtr;
        lwip_init();
#if (TCPIP_CONTROLLER_NUM > 0u)
        TcpIp_ControllerInit(TcpIp_PbCfgPtr->ctrlNum, TcpIp_PbCfgPtr->CtrlPtr);
#endif /* (TCPIP_CONTROLLER_NUM > 0) */
#if (TCPIP_SOCKET_NUM > 0u)
        TcpIp_SocketInit(TCPIP_SOCKET_NUM);
#endif /* (TCPIP_SOCKET_NUM > 0u) */
        TcpIp_PeriodTimerInit();
#if (STD_ON == TCPIP_TCP_TLS_ENABLED)
        TcpIp_TlsInit(TcpIp_PbCfgPtr->TlsCfgPtr);
#endif/* (STD_ON == TCPIP_TCP_TLS_ENABLED) */
#if (TCPIP_LOCAL_ADR_NUM > 0u)
        TcpIp_LocalAdrInit(TcpIp_PbCfgPtr->localAdrNum, TcpIp_PbCfgPtr->LocalAdrPtr);
#endif /* (TCPIP_LOCAL_ADR_NUM > 0u) */
#if (STD_ON == TCPIP_INITIALIZATION_AVAILABLE)
        TcpIp_InitState = TCPIP_STATE_INIT;
#endif /* (STD_ON == TCPIP_INITIALIZATION_AVAILABLE) */
    }
}

#if (STD_ON == TCPIP_VERSION_INFO_API)
/***********************************************************************************************************************
 * Service ID[hex]:     0x02
 * Sync/Async:          Synchronous
 * Reentrancy:          Reentrant
 * Parameters (in):     None
 * Parameters(inout):   None
 * Parameters (out):    versioninfo Pointer to where to store the version information of this module.
 * Return value:        None
 * Description:         Returns the version information.
***********************************************************************************************************************/
FUNC(void, TCPIP_CODE) TcpIp_GetVersionInfo(
    P2VAR(Std_VersionInfoType, AUTOMATIC, TCPIP_APPL_DATA) versioninfo)                                                 /* PRQA S 3432 */ /* MISRA Rule 20.7 */
{
#if (STD_ON == TCPIP_DEV_ERROR_DETECT)

    if (NULL_PTR == versioninfo)
    {
        TCPIP_DET(TCPIP_SID_GETVERSIONINFO, TCPIP_E_PARAM_POINTER);
    }
    else
#endif /* (STD_ON == TCPIP_DEV_ERROR_DETECT) */
    {
        versioninfo->moduleID = TCPIP_MODULE_ID;
        versioninfo->vendorID = TCPIP_VENDOR_ID;
        versioninfo->sw_major_version = TCPIP_C_SW_MAJOR_VERSION;
        versioninfo->sw_minor_version = TCPIP_C_SW_MINOR_VERSION;
        versioninfo->sw_patch_version = TCPIP_C_SW_PATCH_VERSION;
    }
}
#endif /* (STD_ON == TCPIP_VERSION_INFO_API) */

/***********************************************************************************************************************
 * Service ID[hex]:     0x04
 * Sync/Async:          Asynchronous
 * Reentrancy:          Reentrant for different SocketIds. Non reentrant for the same SocketId.
 * Parameters (in):     SocketId: Socket handle identifying the local socket resource.
 *                      Abort TRUE: connection will immediately be terminated by sending a RST-Segment and releasing all
 *                      related resources.FALSE: connection will be terminated after performing a regular connection
 *                      termination handshake and releasing all related resources.
 * Parameters(inout):   None
 * Parameters (out):    None
 * Return value:        Std_ReturnType E_OK: The request has been accepted
 * E_NOT_OK:            The request has not been accepted.
 * Description:         By this API service the TCP/IP stack is requested to close the socket and release all related
 *                      resources.
***********************************************************************************************************************/
FUNC(Std_ReturnType, TCPIP_CODE) TcpIp_Close(
    VAR(TcpIp_SocketIdType, AUTOMATIC) SocketId,
    VAR(boolean, AUTOMATIC) Abort)
{
    Std_ReturnType ret = E_NOT_OK;
#if (STD_ON == TCPIP_DEV_ERROR_DETECT)

    if (TCPIP_STATE_INIT != TcpIp_InitState)
    {
        TCPIP_DET(TCPIP_SID_CLOSE, TCPIP_E_NOTINIT);
    }
    else if (SocketId >= TCPIP_SOCKET_NUM)
    {
        TCPIP_DET(TCPIP_SID_CLOSE, TCPIP_E_INV_ARG);
    }
    else
#endif /* (STD_ON == TCPIP_DEV_ERROR_DETECT) */
    {
        ret = TcpIp_CloseSocketHandle(SocketId, Abort);
    }

    return ret;
}

/**********************************************************************************************************************
 * Service ID[hex]:     0x05
 * Sync/Async:          Synchronous
 * Reentrancy:          Reentrant for different SocketIds. Non reentrant for the same SocketId.
 * Parameters (in):     SocketId: Socket identifier of the related local socket resource.
 *                      LocalAddrId: IP address identifier representing the local IP address and EthIf controller to
 *                      bind the socket to.
 * Parameters (inout):  PortPtr Pointer to memory where the local port to which the socket shall be bound is specified.
 *                      In case the parameter is specified as TCPIP_PORT_ANY, the TCP/IP stack shall choose the
 *                      local port automatically from the range 49152 to 65535 and shall update the parameter to the
 *                      chosen value.
 * Parameters (out):    None
 * Return value:        E_OK: The request has been accepted
 *                      E_NOT_OK The request has not been accepted (e.g. address in use)
 * Description:         By this API service the TCP/IP stack is requested to bind a UDP or TCP socket to a local
 *                      resource.
***********************************************************************************************************************/
FUNC(Std_ReturnType, TCPIP_CODE) TcpIp_Bind(
    VAR(TcpIp_SocketIdType, AUTOMATIC) SocketId,
    VAR(TcpIp_LocalAddrIdType, AUTOMATIC) LocalAddrId,
    P2VAR(uint16, AUTOMATIC, TCPIP_APPL_DATA) PortPtr)                                                                  /* PRQA S 3432 */ /* MISRA Rule 20.7 */
{
    Std_ReturnType ret = E_NOT_OK;
#if (STD_ON == TCPIP_DEV_ERROR_DETECT)

    if (TCPIP_STATE_INIT != TcpIp_InitState)
    {
        TCPIP_DET(TCPIP_SID_BIND, TCPIP_E_NOTINIT);
    }
    else if (NULL_PTR == PortPtr)
    {
        TCPIP_DET(TCPIP_SID_BIND, TCPIP_E_PARAM_POINTER);
    }
    else if ((SocketId >= TCPIP_SOCKET_NUM) ||
             ((LocalAddrId >= TCPIP_LOCAL_ADR_NUM) && (LocalAddrId != TCPIP_LOCALADDRID_ANY)))
    {
        TCPIP_DET(TCPIP_SID_BIND, TCPIP_E_INV_ARG);
    }
    else
#endif /* (STD_ON == TCPIP_DEV_ERROR_DETECT) */
    {
#if ((TCPIP_LOCAL_ADR_NUM > 0u)&&(TCPIP_SOCKET_NUM > 0u))
        ret = TcpIp_InnerBind(TcpIp_PbCfgPtr->LocalAdrPtr[LocalAddrId].ctrlIndex,
                              SocketId, LocalAddrId, PortPtr);
#endif/* ((TCPIP_LOCAL_ADR_NUM > 0u)&&(TCPIP_SOCKET_NUM > 0u)) */
    }

    return ret;
}
#if (STD_ON == TCPIP_TCP_ENABLED)
/***********************************************************************************************************************
 * Service ID[hex]:     0x06
 * Sync/Async:          Asynchronous
 * Reentrancy:          Reentrant for different SocketIds. Non reentrant for the same SocketId.
 * Parameters (in):     SocketId: Socket identifier of the related local socket resource.
 *                      RemoteAddrPtr IP address and port of the remote host to connect to.
 * Parameters(inout):   None
 * Parameters (out):    None
 * Return value:        Std_ReturnType E_OK: The request has been accepted
 *                      E_NOT_OK: The request has not been accepted, e.g. connection is already established or no route
 *                      to destination specified by remoteAddrPtr found.
 * Description:         By this API service the TCP/IP stack is requested to establish a TCP connection to the
 *                      configured peer.
***********************************************************************************************************************/
FUNC(Std_ReturnType, TCPIP_CODE) TcpIp_TcpConnect(
    VAR(TcpIp_SocketIdType, AUTOMATIC) SocketId,
    P2CONST(TcpIp_SockAddrType, AUTOMATIC, TCPIP_APPL_CONST) RemoteAddrPtr)
{
    Std_ReturnType ret = E_NOT_OK;
#if (STD_ON == TCPIP_DEV_ERROR_DETECT)

    if (TCPIP_STATE_INIT != TcpIp_InitState)
    {
        TCPIP_DET(TCPIP_SID_TCPCONNECT, TCPIP_E_NOTINIT);
    }
    else if (NULL_PTR == RemoteAddrPtr)
    {
        TCPIP_DET(TCPIP_SID_TCPCONNECT, TCPIP_E_PARAM_POINTER);
    }
    else if (SocketId >= TCPIP_SOCKET_NUM)
    {
        TCPIP_DET(TCPIP_SID_TCPCONNECT, TCPIP_E_INV_ARG);
    }
    else
#endif /* (STD_ON == TCPIP_DEV_ERROR_DETECT) */
    {
        ret = TcpIp_InnerTcpConnect(SocketId, RemoteAddrPtr);
    }

    return ret;
}

/***********************************************************************************************************************
 * Service ID[hex]:     0x07
 * Sync/Async:          Asynchronous
 * Reentrancy:          Reentrant for different SocketIds. Non reentrant for the same SocketId.
 * Parameters (in):     SocketId: Socket identifier of the related local socket resource.
 *                      MaxChannels: Maximum number of new parallel connections established on this listen connection.
 * Parameters(inout):   None
 * Parameters (out):    None
 * Return value:        Std_ReturnType E_OK: The request has been accepted
 *                      E_NOT_OK: The request has not been accepted, the socket is not configured to be a server socket.
 * Description:         By this API service the TCP/IP stack is requested to listen on the TCP socket specified
 *                      by the socket identifier.
***********************************************************************************************************************/
FUNC(Std_ReturnType, TCPIP_CODE) TcpIp_TcpListen(
    VAR(TcpIp_SocketIdType, AUTOMATIC) SocketId,
    VAR(uint16, AUTOMATIC) MaxChannels)
{
    Std_ReturnType ret = E_NOT_OK;
#if (STD_ON == TCPIP_DEV_ERROR_DETECT)

    if (TCPIP_STATE_INIT != TcpIp_InitState)
    {
        TCPIP_DET(TCPIP_SID_TCPLISTEN, TCPIP_E_NOTINIT);
    }
    else if (SocketId >= TCPIP_SOCKET_NUM)
    {
        TCPIP_DET(TCPIP_SID_TCPLISTEN, TCPIP_E_INV_ARG);
    }
    else
#endif /* (STD_ON == TCPIP_DEV_ERROR_DETECT) */
    {
        uint8 maxCh = (MaxChannels > 0xffu) ? 0xffu : (uint8)MaxChannels;
        ret = TcpIp_InnerTcpListen(SocketId, maxCh);
    }

    return ret;
}

/***********************************************************************************************************************
 * Service ID[hex]:     0x08
 * Sync/Async:          Asynchronous
 * Reentrancy:          Reentrant for different SocketIds. Non reentrant for the same SocketId.
 * Parameters (in):     SocketId Socket identifier of the related local socket resource
 *                      Length Number of bytes finally consumed by the upper layer.
 * Parameters(inout):   None
 * Parameters (out):    None
 * Return value:        Std_ReturnType E_OK: The request has been accepted
 *                      E_NOT_OK: The request has not been accepted
 * Description:         By this API service the reception of socket data is confirmed to the TCP/IP stack.
***********************************************************************************************************************/
FUNC(Std_ReturnType, TCPIP_CODE) TcpIp_TcpReceived(
    VAR(TcpIp_SocketIdType, AUTOMATIC) SocketId,
    VAR(uint32, AUTOMATIC) Length)
{
    Std_ReturnType ret = E_NOT_OK;
#if (STD_ON == TCPIP_DEV_ERROR_DETECT)

    if (TCPIP_STATE_INIT != TcpIp_InitState)
    {
        TCPIP_DET(TCPIP_SID_TCPRECEIVED, TCPIP_E_NOTINIT);
    }
    else if (SocketId >= TCPIP_SOCKET_NUM)
    {
        TCPIP_DET(TCPIP_SID_TCPRECEIVED, TCPIP_E_INV_ARG);
    }
    else
#endif /* (STD_ON == TCPIP_DEV_ERROR_DETECT) */
    {
        uint16 revcLen = (Length > 0xffffu) ? 0xffffu : (uint16)Length;
        ret = TcpIp_InnerTcpReceived(SocketId, revcLen);
    }

    return ret;
}
#endif/* (STD_ON == TCPIP_TCP_ENABLED) */



/***********************************************************************************************************************
 * Service ID[hex]:     0x09
 * Sync/Async:          Asynchronous
 * Reentrancy:          Non Reentrant
 * Parameters (in):     CtrlIdx: EthIf controller index to identify the communication network where the TcpIp state is
 *                      requested.
 *                      State: Requested TcpIp state.
 * Parameters(inout):   None
 * Parameters (out):    None
 * Return value:        Std_ReturnType E_OK: Service accepted
 *                      E_NOT_OK: Service denied
 * Description:         By this API service the TCP/IP stack is requested to change the TcpIp state of the communication
 *                      network identified by EthIf controller index.
***********************************************************************************************************************/
FUNC(Std_ReturnType, TCPIP_CODE) TcpIp_RequestComMode(
    VAR(uint8, AUTOMATIC) CtrlIdx,
    VAR(TcpIp_StateType, AUTOMATIC) State)
{
    Std_ReturnType ret = E_NOT_OK;
#if (STD_ON == TCPIP_DEV_ERROR_DETECT)

    if (TCPIP_STATE_INIT != TcpIp_InitState)
    {
        TCPIP_DET(TCPIP_SID_REQUESTCOMMODE, TCPIP_E_NOTINIT);
    }
    else if ((TCPIP_STATE_STARTUP == State) || (TCPIP_STATE_SHUTDOWN == State))
    {
        TCPIP_DET(TCPIP_SID_REQUESTCOMMODE, TCPIP_E_INV_ARG);
    }
    else
#endif /* (STD_ON == TCPIP_DEV_ERROR_DETECT) */
    {
#if (TCPIP_CONTROLLER_NUM > 0u)
        ret = TcpIp_InnerRequestComMode(CtrlIdx, State);
#endif /* (TCPIP_CONTROLLER_NUM > 0) */
    }

    return ret;
}
/***********************************************************************************************************************
 * Service ID[hex]:     0x0A
 * Sync/Async:          Asynchronous
 * Reentrancy:          Non Reentrant
 * Parameters (in):     LocalAddrId: IP address index specifying the IP address for which an assignment shall be
 *                      initiated.
 *                      Type: Type of IP address assignment which shall be initiated
 *                      LocalIpAddrPtr: Pointer to structure containing the IP address which shall be assigned to the
 *                      EthIf controller indirectly specified via LocalAddrId.
 *                      Netmask: Network mask of IPv4 address or address prefix of IPv6 address in CIDR Notation.
 *                      DefaultRouterPtr: Pointer to structure containing the IP address of the default router
 *                      (gateway) which shall be assigned.
 * Parameters(inout):   None
 * Parameters (out):    None
 * Return value:        Std_ReturnType E_OK: The request has been accepted
 *                      E_NOT_OK: The request has not been accepted
 * Description:         By this API service the local IP address assignment for the IP address specified by LocalAddrId
 *                      shall be initiated.
***********************************************************************************************************************/
FUNC(Std_ReturnType, TCPIP_CODE) TcpIp_RequestIpAddrAssignment(
    VAR(TcpIp_LocalAddrIdType, AUTOMATIC) LocalAddrId,
    VAR(TcpIp_IpAddrAssignmentType, AUTOMATIC) Type,
    P2CONST(TcpIp_SockAddrType, AUTOMATIC, TCPIP_APPL_CONST) LocalIpAddrPtr,
    VAR(uint8, AUTOMATIC) Netmask,
    P2CONST(TcpIp_SockAddrType, AUTOMATIC, TCPIP_APPL_CONST) DefaultRouterPtr)
{
    Std_ReturnType ret = E_NOT_OK;
#if (STD_ON == TCPIP_DEV_ERROR_DETECT)

    if (TCPIP_STATE_INIT != TcpIp_InitState)
    {
        TCPIP_DET(TCPIP_SID_REQUESTIPADDRASSIGNMENT, TCPIP_E_NOTINIT);
    }
    else if (TCPIP_LOCAL_ADR_NUM <= LocalAddrId)
    {
        TCPIP_DET(TCPIP_SID_REQUESTIPADDRASSIGNMENT, TCPIP_E_NOTINIT);
    }
    else
#endif /* (STD_ON == TCPIP_DEV_ERROR_DETECT) */
    {
#if (TCPIP_LOCAL_ADR_NUM > 0)
        const TcpIp_LocalAddrType* localAdrCfgPtr = &TcpIp_PbCfgPtr->LocalAdrPtr[LocalAddrId];
#if (TCPIP_LOCALADDR_MUILT_ASSIGNMENT == STD_ON)
        uint32 addrAssignmentNum = TcpIp_PbCfgPtr->LocalAdrPtr[LocalAddrId].AddrAssignmentNum;

        for (uintx index = 0; index < addrAssignmentNum; index++)
#else/* (TCPIP_LOCALADDR_MUILT_ASSIGNMENT == STD_ON) */
        uintx index = 0;

#endif/* (TCPIP_LOCALADDR_MUILT_ASSIGNMENT == STD_ON) */
        {
            const TcpIp_AddrAssignmentType* addrCfg = &(localAdrCfgPtr->AddrAssignmentCfgPtr[index]);

            if (((Type == addrCfg->AssignmentMethod) || (TCPIP_IPADDR_ASSIGNMENT_ALL == Type))
                && (TCPIP_MANUAL == addrCfg->AssignmentTrigger)
                && (TCPIP_STATE_OFFLINE != TcpIp_GetControlState(localAdrCfgPtr->ctrlIndex)))
            {
                switch (addrCfg->AssignmentMethod)
                {
                    case TCPIP_IPADDR_ASSIGNMENT_STATIC:
                        if (NULL_PTR != localAdrCfgPtr->StaticIpAddressCfgPtr)
                        {
                            /* configure data as local address var */
                            ret = TcpIp_SetLocalAdrIpVar(LocalAddrId, localAdrCfgPtr,
                                                         localAdrCfgPtr->StaticIpAddressCfgPtr);
                        }
                        else if (NULL_PTR != LocalIpAddrPtr)
                        {
#if (TCPIP_SC1 == TCPIP_SCALABILITY_CLASS)
                            uint32 netMask[1] = {0};
#else
                            uint32 netMask[4] = {0};
#endif/* (TCPIP_SC1 == TCPIP_SCALABILITY_CLASS) */
                            TcpIp_NetMaskExtToInner(Netmask, localAdrCfgPtr->DomainType, netMask);
                            /* function input parameter as local address var */
                            TcpIp_StaticIpAddressConfigType ipAdr = {0};

                            if (NULL_PTR != DefaultRouterPtr)
                            {
                                ipAdr.DefaultRouterPtr = DefaultRouterPtr->addr;
                            }

                            ipAdr.NetmaskPtr = netMask;
                            ipAdr.StaticIpAddressPtr = LocalIpAddrPtr->addr;
                            ret = TcpIp_SetLocalAdrIpVar(LocalAddrId, localAdrCfgPtr, &ipAdr);
                        }
                        else
                        {
                            TCPIP_CHECK_OUTPUT("input parameters is error\n");
                        }

                        break;

                    case TCPIP_IPADDR_ASSIGNMENT_DHCP:
#if (STD_ON == TCPIP_DHCP_CLIENT_ENABLED)
                        ret = TcpIp_StartDhcp(localAdrCfgPtr->ctrlIndex);
#endif/* (STD_ON == TCPIP_DHCP_CLIENT_ENABLED) */
                        break;

                    case TCPIP_IPADDR_ASSIGNMENT_LINKLOCAL_DOIP:
                    case TCPIP_IPADDR_ASSIGNMENT_LINKLOCAL:
#if(STD_ON == TCPIP_AUTOIP_ENABLED)
                        ret = TcpIp_StartAutoIp(localAdrCfgPtr->ctrlIndex);
#endif/* (STD_ON == TCPIP_AUTOIP_ENABLED) */
                        break;

                    default:                                                                                            /* PRQA S 2016 */ /* MISRA Rule 16.4 */
                        break;
                }

#if (TCPIP_LOCALADDR_MUILT_ASSIGNMENT == STD_ON)
                /* find type is accordance shall be quit pool */
                break;
#endif/* (TCPIP_LOCALADDR_MUILT_ASSIGNMENT == STD_ON) */
            }
        }
#endif/* (TCPIP_LOCAL_ADR_NUM > 0) */
    }

    return ret;
}

/***********************************************************************************************************************
 * Service ID[hex]:     0x0B
 * Sync/Async:          Asynchronous
 * Reentrancy:          Non Reentrant
 * Parameters (in):     LocalAddrId IP address index specifying the IP address for which an assignment shall be
 *                      released.
 * Parameters(inout):   None
 * Parameters (out):    None
 * Return value:        Std_ReturnType E_OK: The request has been accepted
 *                      E_NOT_OK: The request has not been accepted
 * Description:         By this API service the local IP address assignment for the IP address specified by LocalAddrId
 *                      shall be released.
***********************************************************************************************************************/
FUNC(Std_ReturnType, TCPIP_CODE) TcpIp_ReleaseIpAddrAssignment(
    VAR(TcpIp_LocalAddrIdType, AUTOMATIC) LocalAddrId)
{
    Std_ReturnType ret = E_NOT_OK;
#if (STD_ON == TCPIP_DEV_ERROR_DETECT)

    if (TCPIP_STATE_INIT != TcpIp_InitState)
    {
        TCPIP_DET(TCPIP_SID_RELEASEIPADDRASSIGNMENT, TCPIP_E_NOTINIT);
    }
    else if (TCPIP_LOCAL_ADR_NUM <= LocalAddrId)
    {
        TCPIP_DET(TCPIP_SID_RELEASEIPADDRASSIGNMENT, TCPIP_E_INV_ARG);
    }
    else
#endif /* (STD_ON == TCPIP_DEV_ERROR_DETECT) */
    {
#if (TCPIP_LOCAL_ADR_NUM > 0)
        const TcpIp_LocalAddrType* localAdrCfgPtr = &TcpIp_PbCfgPtr->LocalAdrPtr[LocalAddrId];
#if (TCPIP_LOCALADDR_MUILT_ASSIGNMENT == STD_ON)
        uint32 addrAssignmentNum = TcpIp_PbCfgPtr->LocalAdrPtr[LocalAddrId].AddrAssignmentNum;

        for (uint32 index = 0; index < addrAssignmentNum; index++)
#else/* (TCPIP_LOCALADDR_MUILT_ASSIGNMENT != STD_ON) */
        uint32 index = 0;

#endif/* (TCPIP_LOCALADDR_MUILT_ASSIGNMENT == STD_ON) */
        {
            const TcpIp_AddrAssignmentType* addrCfg = &(localAdrCfgPtr->AddrAssignmentCfgPtr[index]);

            /* [SWS_TCPIP_00199] release TCPIP_AUTOMATIC shall be reject and return E_NOT_OK */
            if ((TCPIP_MANUAL == addrCfg->AssignmentTrigger)
                && (TCPIP_STATE_OFFLINE != TcpIp_GetControlState(localAdrCfgPtr->ctrlIndex)))
            {
                ret = TcpIp_ClearLocalAdrIpVar(LocalAddrId, localAdrCfgPtr->ctrlIndex, addrCfg->AssignmentMethod);
            }

#if (TCPIP_LOCALADDR_MUILT_ASSIGNMENT == STD_ON)

            if (E_OK != ret)
            {
                break;
            }

#endif/* (TCPIP_LOCALADDR_MUILT_ASSIGNMENT == STD_ON) */
        }
    }

#endif/* (TCPIP_LOCAL_ADR_NUM > 0) */
    return ret;
}
#if ((STD_ON == TCPIP_DHCP_CLIENT_ENABLED) && (STD_ON == TCPIP_RESET_IP_ASSIGNMENT_API))
/***********************************************************************************************************************
 * Service ID[hex]:     0x1b
 * Sync/Async:          Synchronous /Asynchronous
 * Reentrancy:          Non Reentrant
 * Parameters (in):     None
 * Parameters(inout):   None
 * Parameters (out):    None
 * Return value:        Std_ReturnType E_OK: success
 *                      E_NOT_OK: switch port could not be initialized
 * Description:         Resets all learned IP-addresses to invalid values.
***********************************************************************************************************************/
FUNC(Std_ReturnType, TCPIP_CODE) TcpIp_ResetIpAssignment(void)
{
    Std_ReturnType ret = E_NOT_OK;
#if (STD_ON == TCPIP_DEV_ERROR_DETECT)

    if (TCPIP_STATE_INIT != TcpIp_InitState)
    {
        TCPIP_DET(TCPIP_SID_RESETIPASSIGNMENT, TCPIP_E_NOTINIT);
    }
    else
#endif /* (STD_ON == TCPIP_DEV_ERROR_DETECT) */
    {
    }

    return ret;
}
#endif/* ((STD_ON == TCPIP_DHCP_CLIENT_ENABLED) && (STD_ON == TCPIP_RESET_IP_ASSIGNMENT_API)) */
#if (STD_ON == TCPIP_ICMP_ENABLED)
#if ((TCPIP_SC1 == TCPIP_SCALABILITY_CLASS) || (TCPIP_SC3 == TCPIP_SCALABILITY_CLASS))
/***********************************************************************************************************************
 * Service ID[hex]:     0x0C
 * Sync/Async:          Synchronous
 * Reentrancy:          Non Reentrant
 * Parameters (in):     LocalIpAddrId: IP address identifier representing the local IP address and EthIf controller
 *                      which shall be used for transmission of the ICMP message.
 *                      RemoteAddrPtr: pointer to struct representing the remote address Ttl Time to live value to be
 *                      used for the ICMP message. If 0 is specified the default value shall be used.
 *                      Type: type field value to be used in the ICMP message
 *                      Code: code field value to be used in the ICMP message
 *                      DataLength: length of ICMP message
 *                      DataPtr: Pointer to data which shall be sent as ICMP message data
 * Parameters(inout):   None
 * Parameters (out):    None
 * Return value:        Std_ReturnType Result of operation
 *                      E_OK: The ICMP message has been sent successfully
 *                      E_NOT_OK: The ICMP message was not sent.
 * Description:         By this API service the TCP/IP stack sends an ICMP message according to the specified
 *                      parameters.
***********************************************************************************************************************/
FUNC(Std_ReturnType, TCPIP_CODE) TcpIp_IcmpTransmit(
    VAR(TcpIp_LocalAddrIdType, AUTOMATIC) LocalIpAddrId,
    P2CONST(TcpIp_SockAddrType, AUTOMATIC, TCPIP_APPL_CONST) RemoteAddrPtr,
    VAR(uint8, AUTOMATIC) Ttl,
    VAR(uint8, AUTOMATIC) Type,
    VAR(uint8, AUTOMATIC) Code,
    VAR(uint16, AUTOMATIC) DataLength,
    P2CONST(uint8, AUTOMATIC, TCPIP_APPL_CONST) DataPtr)
{
    Std_ReturnType ret = E_NOT_OK;
#if (STD_ON == TCPIP_DEV_ERROR_DETECT)

    if (TCPIP_STATE_INIT != TcpIp_InitState)
    {
        TCPIP_DET(TCPIP_SID_ICMPTRANSMIT, TCPIP_E_NOTINIT);
    }
    else if ((TCPIP_LOCAL_ADR_NUM <= LocalIpAddrId) || (0u == DataLength))
    {
        TCPIP_DET(TCPIP_SID_ICMPTRANSMIT, TCPIP_E_INV_ARG);
    }
    else if (NULL_PTR == DataPtr)
    {
        TCPIP_DET(TCPIP_SID_ICMPTRANSMIT, TCPIP_E_PARAM_POINTER);
    }
    else
#endif /* (STD_ON == TCPIP_DEV_ERROR_DETECT) */
    {
#if (TCPIP_CONTROLLER_NUM > 0u)
        TcpIp_IcmpTransDataType icmpPara = {0};
        icmpPara.ttl = Ttl;
        icmpPara.type = Type;
        icmpPara.code = Code;
        icmpPara.dataPtr = DataPtr;
        icmpPara.dataLength = DataLength;
        ret = TcpIp_InnerIcmpTransmit(LocalIpAddrId,
                                      TcpIp_PbCfgPtr->LocalAdrPtr[LocalIpAddrId].ctrlIndex,
                                      RemoteAddrPtr, &icmpPara);
#endif/* (TCPIP_CONTROLLER_NUM > 0u) */
    }

    return ret;
}
#endif/* ((TCPIP_SC1 == TCPIP_SCALABILITY_CLASS) || (TCPIP_SC3 == TCPIP_SCALABILITY_CLASS)) */
#if ((TCPIP_SC2 == TCPIP_SCALABILITY_CLASS) || (TCPIP_SC3 == TCPIP_SCALABILITY_CLASS))
/***********************************************************************************************************************
 * Service ID[hex]:     0x18
 * Sync/Async:          Synchronous
 * Reentrancy:          Non Reentrant
 * Parameters (in):     LocalIpAddrId: IP address identifier representing the local IP address and EthIf controller
 *                      which shall be used for transmission of the ICMPv6 message.
 *                      RemoteAddrPtr: pointer to struct representing the remote address HopLimit Hop Limit value to
 *                      be used for the ICMPv6 message. If 0 is specified the default value shall be used.
 *                      Type: type field value to be used in the ICMPv6 message.
 *                      Code: code field value to be used in the ICMPv6 message
 *                      DataLength: length of ICMPv6 message
 *                      DataPtr: Pointer to data which shall be sent as ICMPv6 message data
 * Parameters(inout):   None
 * Parameters (out):    None
 * Return value:        Std_ReturnType Result of operation
 *                      E_OK: The ICMPv6 message has been sent successfully
 *                      E_NOT_OK: The ICMPv6 message was not sent.
 * Description:         By this API service the TCP/IP stack sends an ICMPv6 message according to the
 *                      specified parameters.
***********************************************************************************************************************/
FUNC(Std_ReturnType, TCPIP_CODE) TcpIp_IcmpV6Transmit(
    VAR(TcpIp_LocalAddrIdType, AUTOMATIC) LocalIpAddrId,
    P2CONST(TcpIp_SockAddrType, AUTOMATIC, TCPIP_APPL_CONST) RemoteAddrPtr,
    VAR(uint8, AUTOMATIC) HopLimit,
    VAR(uint8, AUTOMATIC) Type,
    VAR(uint8, AUTOMATIC) Code,
    VAR(uint16, AUTOMATIC) DataLength,
    P2CONST(uint8, AUTOMATIC, TCPIP_APPL_CONST) DataPtr)
{
    Std_ReturnType ret = E_NOT_OK;
#if (STD_ON == TCPIP_DEV_ERROR_DETECT)

    if (TCPIP_STATE_INIT != TcpIp_InitState)
    {
        TCPIP_DET(TCPIP_SID_ICMPV6TRANSMIT, TCPIP_E_NOTINIT);
    }
    else
#endif /* (STD_ON == TCPIP_DEV_ERROR_DETECT) */
    {
    }

    return ret;
}
#endif/* ((TCPIP_SC2 == TCPIP_SCALABILITY_CLASS) || (TCPIP_SC3 == TCPIP_SCALABILITY_CLASS)) */
#endif/* (STD_ON == TCPIP_ICMP_ENABLED) */
#if ((TCPIP_SC1 == TCPIP_SCALABILITY_CLASS) || (TCPIP_SC3 == TCPIP_SCALABILITY_CLASS))
/***********************************************************************************************************************
 * Service ID[hex]:     0x0D
 * Sync/Async:          Synchronous
 * Reentrancy:          Non Reentrant
 * Parameters (in):     LocalIpAddrId IP address identifier representing the local IP address and EthIf controller for
 *                      which the DHCP option shall be read.
 *                      Option: DHCP option according to IEFT RfC 2132, e.g. hostname
 *                      DataPtr: Pointer to memory containing DHCP option data
 * Parameters(inout):   DataLength: As input parameter, contains the length of the provided data buffer. Will be
 *                      overwritten with the length of the actual data.
 * Parameters (out):    None
 * Return value:        Std_ReturnType Result of operation
 *                      E_OK requested data retrieved successfully.
 *                      E_NOT_OK requested data could not be retrieved.
 * Description:         By this API service the TCP/IP stack retrieves DHCP option data identified by parameter option
 *                      for already received DHCP options.
***********************************************************************************************************************/
FUNC(Std_ReturnType, TCPIP_CODE) TcpIp_DhcpReadOption(
    VAR(TcpIp_LocalAddrIdType, AUTOMATIC) LocalIpAddrId,
    VAR(uint8, AUTOMATIC) Option,
    P2VAR(uint8, AUTOMATIC, TCPIP_APPL_DATA) DataLength,                                                                /* PRQA S 3432 */ /* MISRA Rule 20.7 */
    P2VAR(uint8, AUTOMATIC, TCPIP_APPL_DATA) DataPtr)                                                                   /* PRQA S 3432 */ /* MISRA Rule 20.7 */
{
    TCPIP_UNUSED_ARG(LocalIpAddrId);
    TCPIP_UNUSED_ARG(Option);
    TCPIP_UNUSED_ARG(DataLength);
    TCPIP_UNUSED_ARG(DataPtr);
    Std_ReturnType ret = E_NOT_OK;
#if (STD_ON == TCPIP_DEV_ERROR_DETECT)

    if (TCPIP_STATE_INIT != TcpIp_InitState)
    {
        TCPIP_DET(TCPIP_SID_DHCPREADOPTION, TCPIP_E_NOTINIT);
    }
    else if (TCPIP_LOCAL_ADR_NUM <= LocalIpAddrId)
    {
        TCPIP_DET(TCPIP_SID_DHCPREADOPTION, TCPIP_E_INV_ARG);
    }
    else if ((NULL_PTR == DataLength) || (NULL_PTR == DataPtr))
    {
        TCPIP_DET(TCPIP_SID_DHCPREADOPTION, TCPIP_E_PARAM_POINTER);
    }
    /* check if the parameter LocalIpAddrId is valid
       check if the parameter Option is valid
       check if the parameter DataLength is valid
       TCPIP_E_INV_ARG*/
    else
#endif /* (STD_ON == TCPIP_DEV_ERROR_DETECT) */
    {
    }

    return ret;
}
#endif/* ((TCPIP_SC1 == TCPIP_SCALABILITY_CLASS) || (TCPIP_SC3 == TCPIP_SCALABILITY_CLASS)) */
#if ((TCPIP_SC2 == TCPIP_SCALABILITY_CLASS) || (TCPIP_SC3 == TCPIP_SCALABILITY_CLASS))
/***********************************************************************************************************************
 * Service ID[hex]:     0x0D
 * Sync/Async:          Synchronous
 * Reentrancy:          Non Reentrant
 * Parameters (in):     LocalIpAddrId IP address identifier representing the local IP address and EthIf controller for
 *                      which the DHCPv6 option shall be read.
 *                      Option: DHCP option according to IEFT RfC 3315, e.g. hostname
 *                      DataPtr: Pointer to memory containing DHCP option data
 * Parameters(inout):   DataLength: As input parameter, contains the length of the provided data buffer. Will be
 *                      overwritten with the length of the actual data.
 * Parameters (out):    None
 * Return value:        Std_ReturnType Result of operation
 *                      E_OK requested data retrieved successfully.
 *                      E_NOT_OK requested data could not be retrieved.
 * Description:         By this API service the TCP/IP stack retrieves DHCP option data identified by parameter option
 *                      for already received DHCP options.
***********************************************************************************************************************/
FUNC(Std_ReturnType, TCPIP_CODE) TcpIp_DhcpV6ReadOption(
    VAR(TcpIp_LocalAddrIdType, AUTOMATIC) LocalIpAddrId,
    VAR(uint8, AUTOMATIC) Option,
    P2VAR(uint8, AUTOMATIC, TCPIP_APPL_DATA) DataLength,                                                                /* PRQA S 3432 */ /* MISRA Rule 20.7 */
    P2VAR(uint8, AUTOMATIC, TCPIP_APPL_DATA) DataPtr)                                                                   /* PRQA S 3432 */ /* MISRA Rule 20.7 */
{
    Std_ReturnType ret = E_NOT_OK;
#if (STD_ON == TCPIP_DEV_ERROR_DETECT)

    if (TCPIP_STATE_INIT != TcpIp_InitState)
    {
        TCPIP_DET(TCPIP_SID_DHCPV6READOPTION, TCPIP_E_NOTINIT);
    }
    else if (TCPIP_LOCAL_ADR_NUM <= LocalIpAddrId)
    {
        TCPIP_DET(TCPIP_SID_DHCPV6READOPTION, TCPIP_E_INV_ARG);
    }
    else if ((NULL_PTR == DataLength) || (NULL_PTR == DataPtr))
    {
        TCPIP_DET(TCPIP_SID_DHCPV6READOPTION, TCPIP_E_PARAM_POINTER);
    }
    else
#endif /* (STD_ON == TCPIP_DEV_ERROR_DETECT) */
    {
    }

    return ret;
}
#endif/* ((TCPIP_SC2 == TCPIP_SCALABILITY_CLASS) || (TCPIP_SC3 == TCPIP_SCALABILITY_CLASS)) */
#if ((TCPIP_SC1 == TCPIP_SCALABILITY_CLASS) || (TCPIP_SC3 == TCPIP_SCALABILITY_CLASS))
/***********************************************************************************************************************
 * Service ID[hex]:     0x0E
 * Sync/Async:          Synchronous
 * Reentrancy:          Non Reentrant
 * Parameters (in):     LocalIpAddrId: IP address identifier representing the local IP address and EthIf controller for
 *                      which the DHCP option shall be written.
 *                      Option: DHCP option according to IEFT RfC 2132, e.g. hostname
 *                      DataLength: length of DHCP option data
 *                      DataPtr: Pointer to memory containing DHCP option data
 * Parameters(inout):   None
 * Parameters (out):    None
 * Return value:        Std_ReturnType: Result of operation
 *                      E_OK no error occured.
 *                      E_NOT_OK DHCP option data could not be written.
 * Description:         By this API service the TCP/IP stack writes the DHCP option data identified by parameter option.
***********************************************************************************************************************/
FUNC(Std_ReturnType, TCPIP_CODE) TcpIp_DhcpWriteOption(
    VAR(TcpIp_LocalAddrIdType, AUTOMATIC) LocalIpAddrId,
    VAR(uint8, AUTOMATIC) Option,
    VAR(uint8, AUTOMATIC) DataLength,
    P2CONST(uint8, AUTOMATIC, TCPIP_APPL_CONST) DataPtr)
{
    TCPIP_UNUSED_ARG(LocalIpAddrId);
    TCPIP_UNUSED_ARG(Option);
    TCPIP_UNUSED_ARG(DataLength);
    TCPIP_UNUSED_ARG(DataPtr);
    Std_ReturnType ret = E_NOT_OK;
#if (STD_ON == TCPIP_DEV_ERROR_DETECT)

    if (TCPIP_STATE_INIT != TcpIp_InitState)
    {
        TCPIP_DET(TCPIP_SID_DHCPWRITEOPTION, TCPIP_E_NOTINIT);
    }
    else if (TCPIP_LOCAL_ADR_NUM <= LocalIpAddrId)
    {
        TCPIP_DET(TCPIP_SID_DHCPWRITEOPTION, TCPIP_E_INV_ARG);
    }
    else
#endif /* (STD_ON == TCPIP_DEV_ERROR_DETECT) */
    {
    }

    return ret;
}
#endif/* ((TCPIP_SC1 == TCPIP_SCALABILITY_CLASS) || (TCPIP_SC3 == TCPIP_SCALABILITY_CLASS)) */
#if ((TCPIP_SC2 == TCPIP_SCALABILITY_CLASS) || (TCPIP_SC3 == TCPIP_SCALABILITY_CLASS))
/***********************************************************************************************************************
 * Service ID[hex]:     0x0E
 * Sync/Async:          Synchronous
 * Reentrancy:          Non Reentrant
 * Parameters (in):     LocalIpAddrId: LocalIpAddrId IP address identifier representing the local IP address and EthIf
 *                      controller for which the DHCPv6 option shall be written.
 *                      Option:DHCP option according to IEFT RfC 3315, e.g. hostname
 *                      DataLength: length of DHCP option data
 *                      DataPtr: Pointer to memory containing DHCP option data
 * Parameters(inout):   None
 * Parameters (out):    None
 * Return value:        Std_ReturnType: Result of operation
 *                      E_OK no error occured.
 *                      E_NOT_OK DHCP option data could not be written.
 * Description:         By this API service the TCP/IP stack writes the DHCP option data identified by parameter option.
***********************************************************************************************************************/
FUNC(Std_ReturnType, TCPIP_CODE) TcpIp_DhcpV6WriteOption(
    VAR(TcpIp_LocalAddrIdType, AUTOMATIC) LocalIpAddrId,
    VAR(uint8, AUTOMATIC) Option,
    VAR(uint8, AUTOMATIC) DataLength,
    P2CONST(uint8, AUTOMATIC, TCPIP_APPL_CONST) DataPtr)
{
    Std_ReturnType ret = E_NOT_OK;
#if (STD_ON == TCPIP_DEV_ERROR_DETECT)

    if (TCPIP_STATE_INIT != TcpIp_InitState)
    {
        TCPIP_DET(TCPIP_SID_DHCPV6WRITEOPTION, TCPIP_E_NOTINIT);
    }
    else if (TCPIP_LOCAL_ADR_NUM <= LocalIpAddrId)
    {
        TCPIP_DET(TCPIP_SID_DHCPV6WRITEOPTION, TCPIP_E_INV_ARG);
    }
    else
#endif /* (STD_ON == TCPIP_DEV_ERROR_DETECT) */
    {
    }
}
#endif/* ((TCPIP_SC2 == TCPIP_SCALABILITY_CLASS) || (TCPIP_SC3 == TCPIP_SCALABILITY_CLASS)) */
/***********************************************************************************************************************
* Service ID[hex]:      0x0F
* Sync/Async:           Synchronous
* Reentrancy:           Reentrant for different SocketIds. Non reentrant for the same SocketId.
* Parameters (in):      SocketId: Socket identifier of the related local socket resource.
*                       ParameterId: Identifier of the parameter to be changed
*                       ParameterValue: Pointer to memory containing the new parameter value
* Parameters(inout):    None
* Parameters (out):     None
* Return value:         Std_ReturnType E_OK: The parameter has been changed successfully.
*                       E_NOT_OK: The parameter could not be changed.
* Description:          By this API service the TCP/IP stack is requested to change a parameter of a socket.E.g. the
                        Nagle algorithm may be controlled by this API
***********************************************************************************************************************/
FUNC(Std_ReturnType, TCPIP_CODE) TcpIp_ChangeParameter(
    VAR(TcpIp_SocketIdType, AUTOMATIC) SocketId,
    VAR(TcpIp_ParamIdType, AUTOMATIC) ParameterId,
    P2CONST(void, AUTOMATIC, TCPIP_APPL_CONST) ParameterValue)
{
    Std_ReturnType ret = E_OK;
#if (STD_ON == TCPIP_DEV_ERROR_DETECT)

    if (TCPIP_STATE_INIT != TcpIp_InitState)
    {
        TCPIP_DET(TCPIP_SID_CHANGEPARAMETER, TCPIP_E_NOTINIT);
    }
    else if (SocketId >= TCPIP_SOCKET_NUM)
    {
        TCPIP_DET(TCPIP_SID_CHANGEPARAMETER, TCPIP_E_INV_ARG);
    }
    else if (NULL_PTR == ParameterValue)
    {
        TCPIP_DET(TCPIP_SID_CHANGEPARAMETER, TCPIP_E_PARAM_POINTER);
    }
    else
#endif /* (STD_ON == TCPIP_DEV_ERROR_DETECT) */
    {
		uintx i;
        uintx limtLen = sizeof(TcpIp_SocketParaHandleTebla) / sizeof(TcpIp_SocketParaHandleTebla[0]);
        
        /* this designed shall be reduce QAC STCYC */
        for (i = 0u; i < limtLen; i++)
        {
            const TcpIp_SocketParaHandleType* socketHandlePtr = &TcpIp_SocketParaHandleTebla[i];

            /* Matches only happen once */
            if (ParameterId == socketHandlePtr->paramId)
            {
                if (socketHandlePtr->praHanldFuncPtr != NULL_PTR)
                {
                    ret = socketHandlePtr->praHanldFuncPtr(SocketId, ParameterId, ParameterValue);
                }

                break;
            }
        }
    }

    return ret;
}
/***********************************************************************************************************************
 * Service ID[hex]:     0x10
 * Sync/Async:          Synchronous
 * Reentrancy:          Reentrant
 * Parameters (in):     LocalAddrId Local address identifier referring to the local IP address which shall be obtained.
 * Parameters(inout):   IpAddrPtr: Pointer to a struct where the IP address shall be stored.The struct member domain
 *                      shall be set to the desired.
 *                      TcpIp_DomainType: and it shall be ensured that the struct is large enough to store an address
 *                      of the selected type (INET or INET6).Struct members not related to the IP address are of
 *                      arbitrary value and shall not be used.
 *                      DefaultRouterPtr: Pointer to struct where the IP address of the default router(gateway) is
 *                      stored (struct member "port" is not used and of arbitrary value). The struct must be of the
 *                      same type and size as IpAddrPtr.
 * Parameters (out):    NetmaskPtr: Pointer to memory where Network mask of IPv4 address or address prefix of IPv6
 *                      address in CIDR Notation is stored
 * Return value:        Std_ReturnType Result of operation
 *                      E_OK: The request was successful
 *                      E_NOT_OK: The request was not successful, e.g. domain in IpAddrPtr and the local domain type do
 *                      not match
 * Description:         Obtains the local IP address actually used by LocalAddrId, the netmask and default router
***********************************************************************************************************************/
FUNC(Std_ReturnType, TCPIP_CODE) TcpIp_GetIpAddr(
    VAR(TcpIp_LocalAddrIdType, AUTOMATIC) LocalAddrId,
    P2VAR(TcpIp_SockAddrType, AUTOMATIC, TCPIP_APPL_DATA) IpAddrPtr,                                                    /* PRQA S 3432 */ /* MISRA Rule 20.7 */
    P2VAR(uint8, AUTOMATIC, TCPIP_APPL_DATA) NetmaskPtr,                                                                /* PRQA S 3432 */ /* MISRA Rule 20.7 */
    P2VAR(TcpIp_SockAddrType, AUTOMATIC, TCPIP_APPL_DATA) DefaultRouterPtr)                                             /* PRQA S 3432 */ /* MISRA Rule 20.7 */
{
    Std_ReturnType ret = E_NOT_OK;
#if (STD_ON == TCPIP_DEV_ERROR_DETECT)

    if (TCPIP_STATE_INIT != TcpIp_InitState)
    {
        TCPIP_DET(TCPIP_SID_GETIPADDR, TCPIP_E_NOTINIT);
    }
    else if ((NULL_PTR == IpAddrPtr) ||
             (NULL_PTR == NetmaskPtr) ||
             (NULL_PTR == DefaultRouterPtr))
    {
        TCPIP_DET(TCPIP_SID_GETIPADDR, TCPIP_E_PARAM_POINTER);
    }
    else
#endif /* (STD_ON == TCPIP_DEV_ERROR_DETECT) */
    {
        TcpIp_SockAddrType netMaskAdr = {0};
        /* The last three parameters can be replaced by structures */
        ret = TcpIp_InnerGetIpAddr(LocalAddrId, IpAddrPtr, &netMaskAdr, DefaultRouterPtr);
        TcpIp_NetMaskInnerToExt(TcpIp_PbCfgPtr->LocalAdrPtr[LocalAddrId].DomainType, netMaskAdr.addr, NetmaskPtr);
    }

    return ret;
}
/***********************************************************************************************************************
 * Service ID[hex]:     0x11
 * Sync/Async:          Synchronous
 * Reentrancy:          Non Reentrant
 * Parameters (in):     LocalAddrId Local address identifier implicitely specifing the EthIf controller for which the
 *                      physical address shall be obtained.
 * Parameters(inout):   None
 * Parameters (out):    PhysAddrPtr Pointer to the memory where the physical source address (MAC address) in network
 *                      byte order is stored
 * Return value:        Std_ReturnType Result of operation
 *                      E_OK The request was successful
 *                      E_NOT_OK The request was not successful, e.g. no unique Ctrl specified via IpAddrId.
 * Description:         Obtains the physical source address used by the EthIf controller implicitly specified via
 *                      LocalAddrId.
***********************************************************************************************************************/
FUNC(Std_ReturnType, TCPIP_CODE) TcpIp_GetPhysAddr(
    VAR(TcpIp_LocalAddrIdType, AUTOMATIC) LocalAddrId,
    P2VAR(uint8, AUTOMATIC, TCPIP_APPL_DATA) PhysAddrPtr)                                                               /* PRQA S 3432 */ /* MISRA Rule 20.7 */
{
    Std_ReturnType ret = E_NOT_OK;
#if (STD_ON == TCPIP_DEV_ERROR_DETECT)

    if (TCPIP_STATE_INIT != TcpIp_InitState)
    {
        TCPIP_DET(TCPIP_SID_GETPHYSADDR, TCPIP_E_NOTINIT);
    }
    else if (NULL_PTR == PhysAddrPtr)
    {
        TCPIP_DET(TCPIP_SID_GETPHYSADDR, TCPIP_E_PARAM_POINTER);
    }
    else if (LocalAddrId >= TCPIP_LOCAL_ADR_NUM)
    {
        TCPIP_DET(TCPIP_SID_GETPHYSADDR, TCPIP_E_INV_ARG);
    }
    else
#endif /*STD_ON == TCPIP_DEV_ERROR_DETECT*/
    {
#if (TCPIP_CONTROLLER_NUM > 0)
        EthIf_GetPhysAddr(TcpIp_PbCfgPtr->LocalAdrPtr[LocalAddrId].CtrlRef, PhysAddrPtr);
        ret = E_OK;
#endif/* (TCPIP_CONTROLLER_NUM > 0) */
    }

    return ret;
}
/***********************************************************************************************************************
 * Service ID[hex]:     0x16
 * Sync/Async:          Synchronous
 * Reentrancy:          Non Reentrant
 * Parameters (in):     CtrlIdx EthIf controller index to identify the related ARP/NDP table.
 *                      IpAddrPtr specifies the IP address for which the physical address shall be retrieved.
 *                      initRes specifies if the address resolution shall be initiated (TRUE) or not (FALSE) in case the
 *                      physical address related to the specified IP address is currently unknown.
 * Parameters(inout):   None
 * Parameters (out):    PhysAddrPtr Pointer to the memory where the physical address (MAC address) related to the
 *                      specified IP address is stored in network byte order.
 * Return value:        TcpIp_ReturnType TCPIP_E_OK: specified IP address resolved, physical address provided via
 *                      PhysAddrPtr TCPIP_E_PHYS_ADDR_MISS: physical address currently unknown (address resolution
 *                      initiated if initRes set to TRUE)
 * Description:         TcpIp_GetRemotePhysAddr queries the IP/physical address translation table specified by CtrlIdx
 *                      and returns the physical address related to the IP address specified by IpAddrPtr. In case no
 *                      physical address can be retrieved and parameter initRes is TRUE, address resolution for the
 *                      specified IP address is initiated on the local network.
***********************************************************************************************************************/
FUNC(TcpIp_ReturnType, TCPIP_CODE) TcpIp_GetRemotePhysAddr(
    VAR(uint8, AUTOMATIC) CtrlIdx,
    P2CONST(TcpIp_SockAddrType, AUTOMATIC, TCPIP_APPL_CONST) IpAddrPtr,
    P2VAR(uint8, AUTOMATIC, TCPIP_APPL_DATA) PhysAddrPtr,                                                               /* PRQA S 3432 */ /* MISRA Rule 20.7 */
    VAR(boolean, AUTOMATIC) initRes)
{
    TcpIp_ReturnType ret = TCPIP_E_NOT_OK;
#if (STD_ON == TCPIP_DEV_ERROR_DETECT)

    if (TCPIP_STATE_INIT != TcpIp_InitState)
    {
        TCPIP_DET(TCPIP_SID_GETREMOTEPHYSADDR, TCPIP_E_NOTINIT);
    }
    else if ((NULL_PTR == IpAddrPtr) || (NULL_PTR == PhysAddrPtr))
    {
        TCPIP_DET(TCPIP_SID_GETREMOTEPHYSADDR, TCPIP_E_PARAM_POINTER);
    }
    else
#endif /*STD_ON == TCPIP_DEV_ERROR_DETECT*/
    {
#if (TCPIP_CONTROLLER_NUM > 0u)
#if (TCPIP_SC3 == TCPIP_SCALABILITY_CLASS)

        if (TCPIP_AF_INET == IpAddrPtr->domain)
#endif /* (TCPIP_SC3 == TCPIP_SCALABILITY_CLASS) */
        {
#if ((TCPIP_SC1 == TCPIP_SCALABILITY_CLASS) || (TCPIP_SC3 == TCPIP_SCALABILITY_CLASS))
            /* used arp */
            ret = TcpIp_GetRemotePhysAddrByArp(CtrlIdx, IpAddrPtr, PhysAddrPtr, initRes);
#endif/* ((TCPIP_SC1 == TCPIP_SCALABILITY_CLASS) || (TCPIP_SC3 == TCPIP_SCALABILITY_CLASS)) */
        }

#if (TCPIP_SC3 == TCPIP_SCALABILITY_CLASS)
        else
#endif /* (TCPIP_SC3 == TCPIP_SCALABILITY_CLASS) */
        {
#if ((TCPIP_SC2 == TCPIP_SCALABILITY_CLASS) || (TCPIP_SC3 == TCPIP_SCALABILITY_CLASS))
            /* used ndp ,now is not support */
#endif/* ((TCPIP_SC1 == TCPIP_SCALABILITY_CLASS) || (TCPIP_SC3 == TCPIP_SCALABILITY_CLASS)) */
        }

#endif/* (TCPIP_CONTROLLER_NUM > 0u) */
    }

    return ret;
}
#if (STD_ON == TCPIP_UDP_ENABLED)
/***********************************************************************************************************************
 * Service ID[hex]:     0x12
 * Sync/Async:          Synchronous
 * Reentrancy:          Reentrant for different SocketIds. Non reentrant for the same SocketId.
 * Parameters (in):     SocketId: Socket identifier of the related local socket resource.
 *                      DataPtr: Pointer to a linear buffer of TotalLength bytes containing the data to be transmitted.
 *                      In case DataPtr is a NULL_PTR, TcpIp shall retrieve data from upper layer
 *                      via callback <Up>_CopyTxData().
 *                      RemoteAddrPtr: IP address and port of the remote host to transmit to.
 *                      TotalLength: indicates the payload size of the UDP datagram.
 * Parameters(inout):   None
 * Parameters (out):    None
 * Return value:        Std_ReturnType E_OK: UDP message has been forwarded to EthIf for transmission.
 *                      E_NOT_OK: UDP message could not be sent because of a permanent error,e.g. message is too long.
 * Description:         This service transmits data via UDP to a remote node. The transmission of the data is
 *                      immediately performed with this function call by forwarding it to EthIf.
***********************************************************************************************************************/
FUNC(Std_ReturnType, TCPIP_CODE) TcpIp_UdpTransmit(
    VAR(TcpIp_SocketIdType, AUTOMATIC) SocketId,
    P2CONST(uint8, AUTOMATIC, TCPIP_APPL_CONST) DataPtr,
    P2CONST(TcpIp_SockAddrType, AUTOMATIC, TCPIP_APPL_CONST) RemoteAddrPtr,
    VAR(uint16, AUTOMATIC) TotalLength)
{
    Std_ReturnType ret = E_NOT_OK;
#if (STD_ON == TCPIP_DEV_ERROR_DETECT)

    if (TCPIP_STATE_INIT != TcpIp_InitState)
    {
        TCPIP_DET(TCPIP_SID_UDPTRANSMIT, TCPIP_E_NOTINIT);
    }
    else if (NULL_PTR == RemoteAddrPtr)
    {
        TCPIP_DET(TCPIP_SID_UDPTRANSMIT, TCPIP_E_PARAM_POINTER);
    }
    else if (SocketId >= TCPIP_SOCKET_NUM)
    {
        TCPIP_DET(TCPIP_SID_UDPTRANSMIT, TCPIP_E_INV_ARG);
    }
    else
#endif /* (STD_ON == TCPIP_DEV_ERROR_DETECT) */
    {
        if ((NULL_PTR != DataPtr) || (0u == TotalLength))
        {
            /* direct transmit */
            ret = TcpIp_InnerUdpTransmit(SocketId, DataPtr, RemoteAddrPtr, TotalLength);
        }
        else
        {
            /* shall copy data from upper layer */
            ret = TcpIp_InnerCopyUdpTransmit(SocketId, RemoteAddrPtr, TotalLength);
        }
    }

    return ret;
}
#endif /* (STD_ON == TCPIP_UDP_ENABLED) */
#if (STD_ON == TCPIP_TCP_ENABLED)
/***********************************************************************************************************************
 * Service ID[hex]:     0x13
 * Sync/Async:          Asynchronous
 * Reentrancy:          Reentrant for different SocketIds. Non reentrant for the same SocketId.
 * Parameters (in):     SocketId: Socket identifier of the related local socket resource.
 *                      DataPtr: Pointer to a linear buffer of AvailableLength bytes containing the data to be
 *                      transmitted.In case DataPtr is a NULL_PTR, TcpIp shall retrieve data from upper layer via
 *                      callback <Up>_CopyTxData().
 *                      AvailableLength: Available data for transmission in bytes.
 *                      ForceRetrieve: This parameter is only valid if DataPtr is a NULL_PTR.Indicates how the TCP/IP
 *                      stack retrieves data from upper layer if DataPtr is a NULL_PTR.
 *                      TRUE: the whole data indicated by availableLength shall be retrieved from the upper layer via
 *                      one or multiple <Up>_CopyTxData() calls within the context of this transmit function.
 *                      FALSE: The TCP/IP stack may retrieve up to availableLength data from the upper layer. It is
 *                      allowed to retrieve less than availableLength bytes. Note: Not retrieved data will be provided
 *                      by upper layer with the next call to TcpIp_TcpTransmit (along with new data if available).
 * Parameters(inout):   None
 * Parameters (out):    None
 * Return value:        Std_ReturnType E_OK: The request has been accepted
 *                      E_NOT_OK: The request has not been accepted, e.g. due to a lack of buffer space or the socket
 *                      is not connected.
 * Description:         This service requests transmission of data via TCP to a remote node. The transmission of the
 *                      data is decoupled.
 * Note:                The TCP segment(s) are sent dependent on runtime factors (e.g. receive window) and configuration
 *                      parameter (e.g. Nagle algorithm) .
***********************************************************************************************************************/
FUNC(Std_ReturnType, TCPIP_CODE) TcpIp_TcpTransmit(
    VAR(TcpIp_SocketIdType, AUTOMATIC) SocketId,
    P2CONST(uint8, AUTOMATIC, TCPIP_APPL_CONST) DataPtr,
    VAR(uint32, AUTOMATIC) AvailableLength,
    VAR(boolean, AUTOMATIC) ForceRetrieve)
{
    Std_ReturnType ret = E_NOT_OK;
#if (STD_ON == TCPIP_DEV_ERROR_DETECT)

    if (TCPIP_STATE_INIT != TcpIp_InitState)
    {
        TCPIP_DET(TCPIP_SID_TCPTRANSMIT, TCPIP_E_NOTINIT);
    }
    else if (SocketId >= TCPIP_SOCKET_NUM)
    {
        TCPIP_DET(TCPIP_SID_TCPTRANSMIT, TCPIP_E_INV_ARG);
    }
    else
#endif /* (STD_ON == TCPIP_DEV_ERROR_DETECT) */
    {
        if (0u < AvailableLength)
        {
            uint16 totLen = (AvailableLength <= 0xffffu) ? (uint16)AvailableLength : 0xffffu;

            if (NULL_PTR != DataPtr)
            {
                /* direct transmit */
                ret = TcpIp_InnerTcpTransmit(SocketId, DataPtr, totLen);
            }
            else
            {
                /* shall copy data from upper layer */
                ret = TcpIp_InnerCopyTcpTransmit(SocketId, totLen, ForceRetrieve);
            }
        }
    }

    return ret;
}
#endif /*STD_ON == TCPIP_TCP_ENABLED*/
/***********************************************************************************************************************
 * Service ID[hex]:     0x14
 * Sync/Async:          Synchronous
 * Reentrancy:          Non Reentrant
 * Parameters (in):     CtrlIdx: Index of the EthIf controller.
 *                      FrameType: frame type of received Ethernet frame
 *                      IsBroadcast: parameter to indicate a broadcast frame Specification of TCP/IP Stack
 *                      PhysAddrPtr: pointer to Physical source address (MAC address in network byte order) of
 *                      received Ethernet frame
 *                      DataPtr: Pointer to payload of the received Ethernet frame (i.e. Ethernet header is not
 *                      provided).
 *                      LenByte: Length of received data.
 * Parameters(inout):   None
 * Parameters (out):    None
 * Return value:        None
 * Description:         By this API service the TCP/IP stack gets an indication and the data of a received frame.
***********************************************************************************************************************/
FUNC(void, TCPIP_CODE) TcpIp_RxIndication(
    VAR(uint8, AUTOMATIC) CtrlIdx,
    VAR(Eth_FrameType, AUTOMATIC) FrameType,
    VAR(boolean, AUTOMATIC) IsBroadcast,
    P2CONST(uint8, AUTOMATIC, TCPIP_APPL_CONST) PhysAddrPtr,
    P2CONST(uint8, AUTOMATIC, TCPIP_APPL_DATA) DataPtr,
    VAR(uint16, AUTOMATIC) LenByte)
{
    TCPIP_UNUSED_ARG(PhysAddrPtr);
#if (STD_ON == TCPIP_DEV_ERROR_DETECT)

    if (TCPIP_STATE_INIT != TcpIp_InitState)
    {
        TCPIP_DET(TCPIP_SID_RXINDICATION, TCPIP_E_NOTINIT);
    }
    else
#endif /* (STD_ON == TCPIP_DEV_ERROR_DETECT) */
    {
        uint8 flag = (((boolean)TRUE == IsBroadcast) ? PBUF_FLAG_LLBCAST : 0u);
        TcpIp_InnerRxIndication(CtrlIdx, FrameType, flag, DataPtr, LenByte);
    }
}
/***********************************************************************************************************************
 * Service ID[hex]:         0x15
 * Description:             Schedules the TCP/IP stack. (Entry point for scheduling)
***********************************************************************************************************************/
FUNC(void, TCPIP_CODE) TcpIp_MainFunction(void)
{
#if (STD_ON == TCPIP_INITIALIZATION_AVAILABLE)

    if (TCPIP_STATE_INIT == TcpIp_InitState)
#endif /* (STD_ON == TCPIP_INITIALIZATION_AVAILABLE) */
    {
#if defined(TCPIP_SUUPORT_CTRL_MAINHANDLE)
        TcpIp_ControlPollMainHandle();
#endif/* defined(TCPIP_SUUPORT_CTRL_MAINHANDLE) */
#if (TCPIP_SOCKET_NUM > 0u)
        TcpIp_SocketPollMainHandle();
#endif /* (TCPIP_TCP_SOCKET_MAX > 0u) */
        TcpIp_PeriodTimerMainHandle();
    }
}
/***********************************************************************************************************************
 * Service ID[hex]:     0x03
 * Sync/Async:          Synchronous
 * Reentrancy:          Reentrant
 * Parameters (in):     Domain: IP address family.
 *                      Protocol: Socket protocol as sub-family of parameter type.
 * Parameters(inout):   None
 * Parameters (out):    SocketIdPtr: Pointer to socket identifier representing the requested socket.This socket
 *                      identifier must be provided for all further API calls which requires a SocketId.
 *                      Note: SocketIdPtr is only valid if return value is E_OK.
 * Return value:        Std_ReturnType Result of operation
 *                      E_OK: The request has been accepted
 *                      E_NOT_OK: The request has not been accepted: no free socket
 * Description:         By this API service the TCP/IP stack is requested to allocate a new socket.Note: Each accepted
 *                      incoming TCP connection also allocates a socket resource.
***********************************************************************************************************************/
FUNC(Std_ReturnType, TCPIP_CODE) TcpIp_GetSocket(
    VAR(TcpIp_DomainType, AUTOMATIC) Domain,
    VAR(TcpIp_ProtocolType, AUTOMATIC) Protocol,
#if (STD_ON == TCPIP_MUILT_SOCKET_OWNERCFG)
    VAR(uint8, AUTOMATIC) socketOwnererId,
#endif /* (STD_ON == TCPIP_MUILT_SOCKET_OWNERCFG) */
    P2VAR(TcpIp_SocketIdType, AUTOMATIC, TCPIP_APPL_DATA) SocketIdPtr)                                                  /* PRQA S 3432 */ /* MISRA Rule 20.7 */
{
    Std_ReturnType ret = E_NOT_OK;
#if (STD_ON == TCPIP_DEV_ERROR_DETECT)

    if (TCPIP_STATE_INIT != TcpIp_InitState)
    {
        TCPIP_DET(TCPIP_SID_UP_GETSOCKET, TCPIP_E_NOTINIT);
    }
    else if (NULL_PTR == SocketIdPtr)
    {
        TCPIP_DET(TCPIP_SID_UP_GETSOCKET, TCPIP_E_PARAM_POINTER);
    }
    else if (NULL_PTR == TcpIp_LCfg.SocketOwnerLCfgPtr)
    {
        TCPIP_DET(TCPIP_SID_UP_GETSOCKET, TCPIP_E_INV_ARG);
    }
    else
#endif /* (STD_ON == TCPIP_DEV_ERROR_DETECT) */
    {
#if (STD_ON == TCPIP_MUILT_SOCKET_OWNERCFG)
        const TcpIp_SocketOwnerLCfgType* upSocketApiCfgPtr = &TcpIp_LCfg.SocketOwnerLCfgPtr[socketOwnererId];
#else /* (STD_ON != TCPIP_MUILT_SOCKET_OWNERCFG) */
        const TcpIp_SocketOwnerLCfgType* upSocketApiCfgPtr = TcpIp_LCfg.SocketOwnerLCfgPtr;
#endif /* (STD_ON == TCPIP_MUILT_SOCKET_OWNERCFG) */
#if defined(TCPIP_CHECK)

        if (NULL_PTR != upSocketApiCfgPtr)
#endif/* defined(TCPIP_CHECK) */
        {
#if (STD_ON == TCPIP_TCP_ENABLED)

            if (Protocol == TCPIP_IPPROTO_TCP)
            {
                ret = TcpIp_MallocTcpSocketId(Domain, upSocketApiCfgPtr, SocketIdPtr);
            }

#endif/* (STD_ON == TCPIP_TCP_ENABLED) */
#if (STD_ON == TCPIP_UDP_ENABLED)

            if (Protocol == TCPIP_IPPROTO_UDP)
            {
                ret = TcpIp_MallocUdpSocketId(Domain, upSocketApiCfgPtr, SocketIdPtr);
            }

#endif/* (STD_ON == TCPIP_UDP_ENABLED) */
        }

#if defined(TCPIP_CHECK)
        else
        {
            TCPIP_CHECK_OUTPUT("not socket owner config");
        }

#endif/* defined(TCPIP_CHECK) */
    }

    return ret;
}
#define TCPIP_STOP_SEC_CODE
#include "TcpIp_MemMap.h"
